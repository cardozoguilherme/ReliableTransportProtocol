# Protocolo de Transporte Confi√°vel

## Vis√£o Geral

Este projeto implementa um protocolo de transporte confi√°vel que simula a camada de transporte de redes de computadores. O sistema permite a troca de mensagens entre cliente e servidor usando dois protocolos diferentes: **Go-Back-N** e **Selective Repeat**.

### Objetivo

Demonstrar os conceitos fundamentais de protocolos de transporte confi√°vel, incluindo:

- Janela deslizante
- Controle de fluxo
- Detec√ß√£o e corre√ß√£o de erros
- Retransmiss√£o autom√°tica
- Reconhecimento positivo e negativo

### Arquitetura

```
Cliente ‚Üê‚Üí Servidor
   ‚Üì         ‚Üì
Go-Back-N  ou  Selective Repeat
   ‚Üì         ‚Üì
Timer + NACK + Checksum
```

## Estrutura do Projeto

- **`client.py`** - Cliente que inicia conex√£o, negocia par√¢metros e envia mensagens
- **`server.py`** - Servidor que aceita conex√µes, processa mensagens e reconstr√≥i dados
- **`README.md`** - Documenta√ß√£o completa do projeto

## Entreg√°veis do Projeto

### ‚úÖ **Entrega 1 - Handshake Inicial** (CONCLU√çDA)

**Objetivo:** Aplica√ß√µes cliente e servidor devem se conectar via socket e realizar o handshake inicial.

#### **Implementado:**

- ‚úÖ **Conex√£o via Socket**: Cliente conecta ao servidor via TCP
- ‚úÖ **Handshake Inicial**: Negocia√ß√£o de par√¢metros entre cliente e servidor
- ‚úÖ **Modo de Opera√ß√£o**: Cliente escolhe entre Go-Back-N ou Selective Repeat
- ‚úÖ **Tamanho M√°ximo**: Negocia√ß√£o do limite de caracteres da mensagem
- ‚úÖ **Confirma√ß√£o**: Servidor confirma par√¢metros com handshake_ack

#### **Caracter√≠sticas:**

- **Protocolo de Aplica√ß√£o**: JSON com campos `type`, `max_message_size`, `operation_mode`
- **Framing**: Tamanho da mensagem (4 bytes) + dados JSON
- **Valida√ß√£o**: Servidor confirma par√¢metros recebidos

### ‚úÖ **Entrega 2 - Troca de Mensagens** (CONCLU√çDA)

**Objetivo:** Troca de mensagens entre cliente e servidor considerando um canal de comunica√ß√£o sem erros e perdas.

#### **Implementado:**

- ‚úÖ **Segmenta√ß√£o**: Mensagem dividida em segmentos de 4 caracteres
- ‚úÖ **Janela Deslizante**: Tamanho configur√°vel (1-5 pacotes)
- ‚úÖ **Go-Back-N**: Retransmiss√£o em lote com janela deslizante
- ‚úÖ **Selective Repeat**: Retransmiss√£o seletiva com buffer
- ‚úÖ **Controle de Fluxo**: Paralelismo controlado por janela
- ‚úÖ **Verifica√ß√£o de Limite**: Cliente verifica tamanho m√°ximo da mensagem

#### **Caracter√≠sticas do Transporte Confi√°vel:**

- ‚úÖ **Soma de Verifica√ß√£o**: Checksum simples (soma ASCII % 256)
- ‚úÖ **Temporizador**: Timer de 5 segundos para detec√ß√£o de perdas
- ‚úÖ **N√∫mero de Sequ√™ncia**: Identifica√ß√£o √∫nica de pacotes
- ‚úÖ **Reconhecimento Positivo**: ACK para pacotes v√°lidos
- ‚úÖ **Reconhecimento Negativo**: NACK para pacotes corrompidos
- ‚úÖ **Janela/Paralelismo**: Envio simult√¢neo de m√∫ltiplos pacotes
- ‚úÖ **Algoritmo de Integridade**: Checksum para detec√ß√£o de corrup√ß√£o

### üîÑ **Entrega 3 - Simula√ß√£o de Erros** (PENDENTE)

**Objetivo:** Inser√ß√£o de erros e perdas simulados, bem como a implementa√ß√£o do correto comportamento dos processos.

#### **A Implementar:**

- ‚ùå **Simula√ß√£o de Perdas**: Inserir perdas determin√≠sticas de pacotes
- ‚ùå **Simula√ß√£o de Corrup√ß√£o**: Inserir erros de checksum determin√≠sticos
- ‚ùå **Configura√ß√£o de Erros**: Interface para definir tipos e frequ√™ncia de erros
- ‚ùå **Modo de Teste**: Alternar entre modo normal e modo de simula√ß√£o
- ‚ùå **Estat√≠sticas**: Relat√≥rio de erros inseridos vs detectados

#### **Funcionalidades Planejadas:**

- **Perda de Pacotes**: Simular perda de pacotes espec√≠ficos
- **Corrup√ß√£o de Dados**: Simular checksums incorretos
- **Perda de ACKs**: Simular perda de confirma√ß√µes
- **Atrasos**: Simular atrasos na transmiss√£o
- **Configura√ß√£o**: Interface para escolher tipos de erros

### üéØ **Pontua√ß√£o Extra** (OPCIONAL)

#### **Algoritmo de Integridade** (0,5 pontos)

- ‚úÖ **Algoritmo de checagem de integridade** (checksum implementado)

**Implementa√ß√£o:**

```python
def calculate_checksum(data):
    """Calcula soma de verifica√ß√£o simples"""
    return sum(ord(c) for c in data) % 256

def verify_checksum(payload, received_checksum):
    """Verifica se a soma de verifica√ß√£o est√° correta"""
    calculated_checksum = calculate_checksum(payload)
    return calculated_checksum == received_checksum
```

**Caracter√≠sticas:**

- **M√©todo**: Soma dos valores ASCII m√≥dulo 256
- **Detec√ß√£o**: Identifica corrup√ß√£o de dados
- **Aplica√ß√£o**: Cliente calcula, servidor verifica
- **Integra√ß√£o**: Usado em todos os pacotes de dados

#### **Criptografia Sim√©trica** (0,5 pontos)

- ‚ùå **Criptografia sim√©trica**

### üìä **Status Atual do Projeto**

| Entrega                  | Status              | Progresso | Observa√ß√µes                             |
| ------------------------ | ------------------- | --------- | --------------------------------------- |
| **Entrega 1**            | ‚úÖ **Conclu√≠da**    | 100%      | Handshake implementado                  |
| **Entrega 2**            | ‚úÖ **Conclu√≠da**    | 100%      | Go-Back-N e Selective Repeat funcionais |
| **Entrega 3**            | üîÑ **Pendente**     | 0%        | Simula√ß√£o de erros n√£o implementada     |
| **Extra - Integridade**  | ‚úÖ **Conclu√≠da**    | 100%      | Algoritmo de checagem de integridade    |
| **Extra - Criptografia** | ‚ùå **N√£o iniciada** | 0%        | Criptografia sim√©trica                  |

### üöÄ **Pr√≥ximos Passos**

1. **Implementar Entrega 3**: Simula√ß√£o de erros e perdas
2. **Testes Extensivos**: Validar comportamento com erros
3. **Documenta√ß√£o**: Atualizar manual com simula√ß√£o
4. **Pontua√ß√£o Extra**: Considerar implementa√ß√£o opcional

## Conceitos Fundamentais

### Janela Deslizante

A janela deslizante √© um conjunto de pacotes que podem ser enviados simultaneamente sem aguardar confirma√ß√£o individual. Permite melhor utiliza√ß√£o da largura de banda e paralelismo na transmiss√£o.

### Segmentos vs Pacotes

- **Segmento**: Peda√ßo da mensagem original (4 caracteres)
- **Pacote**: Segmento + metadados (n√∫mero de sequ√™ncia, checksum, tipo)

### Checksum

Soma de verifica√ß√£o simples que detecta corrup√ß√£o de dados:

```python
checksum = sum(ord(c) for c in data) % 256
```

### N√∫mero de Sequ√™ncia

Identificador √∫nico para cada pacote, usado para:

- Controle de ordem
- Detec√ß√£o de duplicatas
- Controle de janela

### Go-Back-N vs Selective Repeat

| Caracter√≠stica    | Go-Back-N                  | Selective Repeat            |
| ----------------- | -------------------------- | --------------------------- |
| **Retransmiss√£o** | Todos os pacotes da janela | Apenas pacote espec√≠fico    |
| **Buffer**        | N√£o usa                    | Usa buffer para reordena√ß√£o |
| **Efici√™ncia**    | Menor com perdas           | Maior com perdas            |
| **Complexidade**  | Simples                    | Mais complexo               |

## Especifica√ß√£o do Protocolo

### Mensagem de Handshake (Cliente ‚Üí Servidor)

```json
{
  "type": "handshake",
  "max_message_size": 100,
  "operation_mode": "go_back_n"
}
```

### Resposta do Handshake (Servidor ‚Üí Cliente)

```json
{
  "type": "handshake_ack",
  "max_message_size": 100,
  "window_size": 5,
  "operation_mode": "go_back_n",
  "status": "success"
}
```

### Pacote de Dados (Cliente ‚Üí Servidor)

```json
{
  "type": "data",
  "seq_num": 0,
  "payload": "Ol√° ",
  "checksum": 188
}
```

### Pacote de Reconhecimento (Servidor ‚Üí Cliente)

```json
{
  "type": "ack",
  "seq_num": 0
}
```

### Pacote de Reconhecimento Negativo (Servidor ‚Üí Cliente)

```json
{
  "type": "nack",
  "seq_num": 0
}
```

## Caracter√≠sticas Implementadas

### ‚úÖ Handshake Inicial

- Negocia√ß√£o de par√¢metros entre cliente e servidor
- Defini√ß√£o do modo de opera√ß√£o (Go-Back-N ou Selective Repeat)
- Configura√ß√£o do tamanho m√°ximo de mensagem
- Confirma√ß√£o de configura√ß√µes

### ‚úÖ Janela Deslizante

- Tamanho configur√°vel (padr√£o: 5 pacotes)
- Envio paralelo de m√∫ltiplos pacotes
- Controle de fluxo eficiente

### ‚úÖ Go-Back-N

- Retransmiss√£o em lote quando NACK √© recebido
- Simplicidade de implementa√ß√£o
- Controle de janela deslizante

### ‚úÖ Selective Repeat

- Buffer de recebimento para pacotes fora de ordem
- Retransmiss√£o seletiva de pacotes espec√≠ficos
- Reordena√ß√£o autom√°tica de pacotes
- Entrega em ordem para a aplica√ß√£o

### ‚úÖ Controle de Erros

- Checksum para detec√ß√£o de corrup√ß√£o
- NACK para pacotes com erro
- Timer para detec√ß√£o de perdas
- Retransmiss√£o autom√°tica

### ‚úÖ Verifica√ß√£o de Limite

- Limite m√°ximo configur√°vel (padr√£o: 100 caracteres)
- Verifica√ß√£o no cliente antes do envio
- Truncamento autom√°tico se exceder limite

## Manual de Execu√ß√£o

### Como Executar

#### 1. Executar o Servidor

```bash
python server.py
```

O servidor ser√° iniciado em `localhost:8080` e aguardar√° conex√µes.

#### 2. Executar o Cliente (em outro terminal)

```bash
python client.py
```

O cliente se conectar√° automaticamente ao servidor, realizar√° o handshake e enviar√° a mensagem.

### Vari√°veis Configur√°veis

#### Cliente (`client.py`)

| Constante          | Localiza√ß√£o | Padr√£o          | Descri√ß√£o                  |
| ------------------ | ----------- | --------------- | -------------------------- |
| `HOST`             | Linha 9     | `'localhost'`   | Endere√ßo do servidor       |
| `PORT`             | Linha 10    | `8080`          | Porta do servidor          |
| `MAX_MESSAGE_SIZE` | Linha 11    | `100`           | Tamanho m√°ximo da mensagem |
| `OPERATION_MODE`   | Linha 12    | `'go_back_n'`   | Modo de opera√ß√£o           |
| `TIMEOUT_DURATION` | Linha 13    | `5.0`           | Timeout em segundos        |
| `TEXT_TO_SEND`     | Linha 14    | Mensagem padr√£o | Texto a ser enviado        |

#### Servidor (`server.py`)

| Constante     | Localiza√ß√£o | Padr√£o        | Descri√ß√£o            |
| ------------- | ----------- | ------------- | -------------------- |
| `HOST`        | Linha 7     | `'localhost'` | Endere√ßo do servidor |
| `PORT`        | Linha 8     | `8080`        | Porta do servidor    |
| `WINDOW_SIZE` | Linha 9     | `5`           | Tamanho da janela    |

### Exemplos de Configura√ß√£o

#### Configurar para Go-Back-N

```python
# Em client.py, linha 12:
OPERATION_MODE = 'go_back_n'
```

#### Configurar para Selective Repeat

```python
# Em client.py, linha 12:
OPERATION_MODE = 'selective_repeat'
```

#### Alterar tamanho da janela

```python
# Em server.py, linha 9:
WINDOW_SIZE = 10  # Janela de 10 pacotes
```

#### Alterar timeout

```python
# Em client.py, linha 13:
TIMEOUT_DURATION = 3.0  # Timeout de 3 segundos
```

#### Alterar mensagem

```python
# Em client.py, linha 14:
TEXT_TO_SEND = "Sua mensagem personalizada aqui"
```

#### Alterar tamanho m√°ximo da mensagem

```python
# Em client.py, linha 11:
MAX_MESSAGE_SIZE = 200  # Limite de 200 caracteres
```

## Fluxos Passo a Passo

### 7.1 Go-Back-N - Cen√°rio de Sucesso

**Situa√ß√£o:** Todos os pacotes s√£o enviados e recebidos corretamente, sem perdas ou corrup√ß√µes.

**Cliente:**

- Passo 1: Inicia handshake (linhas 105-109 em client.py)

  ```python
  handshake_data = {
      "type": "handshake",           # Tipo da mensagem
      "max_message_size": MAX_MESSAGE_SIZE,      # Tamanho m√°ximo da mensagem
      "operation_mode": OPERATION_MODE  # Modo de opera√ß√£o (go_back_n ou selective_repeat)
  }
  send_message(s, handshake_data) # Enviar handshake
  ```

- Passo 2: Recebe confirma√ß√£o do servidor (linha 114 em client.py)

  ```python
  response = receive_message(s) # Receber confirma√ß√£o (ack do servidor)
  ```

- Passo 3: Envia primeira janela [0,1,2,3,4] (linhas 162-176 em client.py)

  ```python
  while next_seq_to_send < min(base_seq + window_size, len(segments)):
      segment = segments[next_seq_to_send]
      checksum = calculate_checksum(segment)
      packet = create_data_packet(next_seq_to_send, segment, checksum)

      print(f"[SEND] Enviando pacote {next_seq_to_send}: '{segment}' (checksum: {checksum})")
      send_message(s, packet)

      # Armazenar pacote enviado
      sent_packets[next_seq_to_send] = packet

      # Iniciar timer para este pacote
      start_timer(next_seq_to_send, packet, s)

      next_seq_to_send += 1
  ```

- Passo 4: Aguarda ACKs sequenciais (linhas 179-195 em client.py)

  ```python
  while base_seq < next_seq_to_send:
      try:
          response = receive_message(s)
          ack_seq = response["seq_num"]

          if response["type"] == "ack":
              print(f"[ACK] ACK recebido para pacote {ack_seq}")
              # Parar timer do pacote confirmado
              stop_timer(ack_seq)
              # Marcar pacote como confirmado
              acknowledged_packets.add(ack_seq)

              # Mover janela se base foi confirmada
              while base_seq in acknowledged_packets:
                  base_seq += 1
                  print(f"[WINDOW] Janela movida. Base agora: {base_seq}")
  ```

**Servidor:**

- Passo 1: Recebe handshake (linha 69 em server.py)

  ```python
  handshake_data = receive_message(client_socket) # Receber handshake do cliente
  ```

- Passo 2: Envia confirma√ß√£o (linhas 73-81 em server.py)

  ```python
  response = {
      "type": "handshake_ack",                                # Confirma√ß√£o do handshake
      "max_message_size": handshake_data["max_message_size"], # Confirmar tamanho
      "window_size": WINDOW_SIZE,                             # Tamanho da janela
      "operation_mode": handshake_data["operation_mode"],     # Confirmar modo
      "status": "success"                                     # Status de sucesso
  }
  send_message(client_socket, response) # Enviar confirma√ß√£o (handshake_ack)
  ```

- Passo 3: Processa pacotes em ordem (linhas 120-130 em server.py)

  ```python
  if operation_mode == "go_back_n":
      # Go-Back-N: Armazenar segmento se for o pr√≥ximo esperado
      if seq_num == expected_seq:
          received_segments.append(payload)  # Adicionar √† lista
          expected_seq += 1  # Pr√≥ximo n√∫mero esperado
          print(f"[OK] Segmento {seq_num} adicionado √† mensagem")

          # Enviar ACK para pacote v√°lido
          ack = create_ack_packet(seq_num)
          send_message(client_socket, ack)
          print(f"[ACK] ACK enviado para pacote {seq_num}")
  ```

**Estado das Vari√°veis:**

- base_seq: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5
- next_seq_to_send: 0 ‚Üí 5
- acknowledged_packets: {} ‚Üí {0} ‚Üí {0,1} ‚Üí {0,1,2} ‚Üí {0,1,2,3} ‚Üí {0,1,2,3,4}

**Resultado:** Janela movida completamente, pr√≥xima janela [5,6,7,8,9] √© enviada.

### 7.2 Go-Back-N - Cen√°rio de Perda de Pacote

**Situa√ß√£o:** Pacote 2 √© perdido durante a transmiss√£o, servidor n√£o recebe.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4] (linhas 162-176 em client.py)
- Passo 2: Recebe ACKs 0 e 1 (linhas 184-195 em client.py)
- Passo 3: N√£o recebe ACK 2, timer expira (linhas 65-80 em client.py)
  ```python
  def timeout_handler():
      print(f"[TIMEOUT] Timeout para pacote {seq_num} - retransmitindo...")
      # Para timeout, sempre retransmitir apenas o pacote espec√≠fico
      # A l√≥gica de Go-Back-N vs Selective Repeat √© tratada no NACK
      send_message(socket_conn, packet)
      print(f"Pacote {seq_num} retransmitido por timeout")
  ```
- Passo 4: Retransmite todos os pacotes da janela [2,3,4] (linhas 199-214 em client.py)

  ```python
  if operation_mode == "go_back_n":
      # Go-Back-N: Parar todos os timers da janela
      for i in range(base_seq, next_seq_to_send):
          stop_timer(i)

      # Go-Back-N: Retransmitir todos os pacotes da janela
      print(f"[GBN] Go-Back-N: Retransmitindo janela a partir de {base_seq}")
      for i in range(base_seq, next_seq_to_send):
          if i in sent_packets:
              packet = sent_packets[i]
              print(f"[RETRY] Retransmitindo pacote {i}: '{packet['payload']}'")
              send_message(s, packet)
              # Reiniciar timer para retransmiss√£o
              start_timer(i, packet, s)
  ```

**Servidor:**

- Passo 1: Recebe pacotes 0 e 1, envia ACKs
- Passo 2: N√£o recebe pacote 2
- Passo 3: Recebe pacotes 3 e 4, mas ignora (fora de ordem)
  ```python
  else:
      print(f"[WARNING] Pacote {seq_num} fora de ordem (esperado: {expected_seq}) - ignorando")
      # Go-Back-N: N√ÉO enviar ACK para pacotes fora de ordem
  ```
- Passo 4: Recebe retransmiss√£o [2,3,4], processa em ordem

**Estado das Vari√°veis:**

- base_seq: 0 ‚Üí 1 ‚Üí 2 (ap√≥s retransmiss√£o)
- expected_seq: 0 ‚Üí 1 ‚Üí 2 (no servidor)

**Resultado:** Pacotes 2, 3, 4 s√£o retransmitidos e processados corretamente.

### 7.3 Go-Back-N - Cen√°rio de Pacote Corrompido

**Situa√ß√£o:** Pacote 2 chega ao servidor com checksum incorreto.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4]
- Passo 2: Recebe ACKs 0 e 1
- Passo 3: Recebe NACK 2 (linhas 196-214 em client.py)
  ```python
  elif response["type"] == "nack":
      if operation_mode == "go_back_n":
          for i in range(base_seq, next_seq_to_send):
              stop_timer(i)
          for i in range(base_seq, next_seq_to_send):
              packet = sent_packets[i]
              send_message(s, packet)
              start_timer(i, packet, s)
  ```

**Servidor:**

- Passo 1: Recebe pacotes 0 e 1, processa corretamente
- Passo 2: Recebe pacote 2 corrompido (linhas 116-164 em server.py)

  ```python
  if verify_checksum(payload, checksum):
      print(f"[OK] Pacote {seq_num} v√°lido: '{payload}' (checksum: {checksum})")
      # Processa pacote v√°lido
  else:
      print(f"[ERROR] Pacote {seq_num} com erro de checksum")

      # Enviar NACK para pacote com erro
      nack = create_nack_packet(seq_num)
      send_message(client_socket, nack)
      print(f"[NACK] NACK enviado para pacote {seq_num}")
  ```

- Passo 3: Envia NACK 2
- Passo 4: Recebe retransmiss√£o [2,3,4], processa corretamente

**Estado das Vari√°veis:**

- base_seq: 0 ‚Üí 1 ‚Üí 2 (ap√≥s retransmiss√£o)
- acknowledged_packets: {0,1} ‚Üí {0,1,2,3,4}

**Resultado:** Pacotes corrompidos s√£o detectados e retransmitidos em lote.

### 7.4 Go-Back-N - Cen√°rio de Timeout

**Situa√ß√£o:** ACK 2 √© perdido, cliente n√£o recebe confirma√ß√£o.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4]
- Passo 2: Recebe ACKs 0 e 1
- Passo 3: Timer do pacote 2 expira (5 segundos) (linhas 65-80 em client.py)
  ```python
  def timeout_handler():
      print(f"[TIMEOUT] Timeout para pacote {seq_num} - retransmitindo...")
      # Para timeout, sempre retransmitir apenas o pacote espec√≠fico
      # A l√≥gica de Go-Back-N vs Selective Repeat √© tratada no NACK
      send_message(socket_conn, packet)
      print(f"Pacote {seq_num} retransmitido por timeout")
  ```
- Passo 4: Retransmite pacote 2 automaticamente

**Servidor:**

- Passo 1: Processa pacotes 0 e 1
- Passo 2: N√£o recebe ACK 2 (perdido)
- Passo 3: Recebe retransmiss√£o do pacote 2
- Passo 4: Processa pacote 2 e envia ACK

**Estado das Vari√°veis:**

- base_seq: 0 ‚Üí 1 ‚Üí 2 (ap√≥s retransmiss√£o)
- timers: {2: timer2} ‚Üí {} (ap√≥s ACK)

**Resultado:** Timeout detecta perda de ACK e retransmite automaticamente.

### 7.5 Selective Repeat - Cen√°rio de Sucesso

**Situa√ß√£o:** Todos os pacotes s√£o enviados e recebidos corretamente, com buffer para reordena√ß√£o.

**Cliente:**

- Passo 1: Inicia handshake com modo "selective_repeat" (linha 108 em client.py)
  ```python
  "operation_mode": "selective_repeat"
  ```
- Passo 2: Envia janela [0,1,2,3,4] (mesmo processo do Go-Back-N)
- Passo 3: Recebe ACKs individuais (linhas 184-195 em client.py)

**Servidor:**

- Passo 1: Configura buffer para Selective Repeat (linhas 93-103 em server.py)

  ```python
  operation_mode = handshake_data.get("operation_mode", "go_back_n")
  window_size = handshake_data.get("window_size", WINDOW_SIZE)
  buffer = {}  # Buffer para armazenar pacotes fora de ordem
  buffer_size = window_size * 2  # Buffer maior que a janela

  if operation_mode == "selective_repeat":
      print(f"[SR] Iniciando Selective Repeat com janela de tamanho: {window_size}")
      print(f"[BUFFER] Buffer de recebimento: {buffer_size} pacotes")
  ```

- Passo 2: Armazena pacotes no buffer (linhas 138-150 em server.py)

  ```python
  elif operation_mode == "selective_repeat":
      # Selective Repeat: Armazenar pacote no buffer
      if seq_num not in buffer:
          buffer[seq_num] = payload
          print(f"[BUFFER] Pacote {seq_num} armazenado no buffer")

      # Verificar se podemos entregar pacotes em ordem
      while expected_seq in buffer:
          received_segments.append(buffer[expected_seq])
          del buffer[expected_seq]  # Remover do buffer
          print(f"[DELIVER] Segmento {expected_seq} entregue em ordem")
          expected_seq += 1

      # Enviar ACK para pacote v√°lido
      ack = create_ack_packet(seq_num)
      send_message(client_socket, ack)
      print(f"[ACK] ACK enviado para pacote {seq_num}")
  ```

- Passo 3: Envia ACK para cada pacote recebido

**Estado das Vari√°veis:**

- buffer: {} ‚Üí {0: "Ol√° "} ‚Üí {} ‚Üí {1: "mund"} ‚Üí {} ‚Üí ...
- expected_seq: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5

**Resultado:** Pacotes s√£o armazenados no buffer e entregues em ordem para a aplica√ß√£o.

### 7.6 Selective Repeat - Cen√°rio de Perda de Pacote

**Situa√ß√£o:** Pacote 2 √© perdido, mas pacotes 3 e 4 chegam ao servidor.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4]
- Passo 2: Recebe ACKs 0, 1, 3, 4
- Passo 3: Timer do pacote 2 expira
- Passo 4: Retransmite apenas pacote 2 (linhas 213-222 em client.py)
  ```python
  elif operation_mode == "selective_repeat":
      # Selective Repeat: Retransmitir apenas o pacote espec√≠fico
      print(f"[SR] Selective Repeat: Retransmitindo apenas pacote {ack_seq}")
      if ack_seq in sent_packets:
          packet = sent_packets[ack_seq]
          print(f"[RETRY] Retransmitindo pacote {ack_seq}: '{packet['payload']}'")
          send_message(s, packet)
          # Reiniciar timer apenas para este pacote
          start_timer(ack_seq, packet, s)
  ```

**Servidor:**

- Passo 1: Recebe pacotes 0, 1, 3, 4
- Passo 2: Armazena pacotes 3 e 4 no buffer (linhas 138-150 em server.py)
  ```python
  # Buffer armazena pacotes fora de ordem
  buffer = {3: "sta ", 4: "√© um"}
  print(f"[BUFFER] Buffer atual: {list(buffer.keys())")
  ```
- Passo 3: Recebe retransmiss√£o do pacote 2
- Passo 4: Entrega pacotes 2, 3, 4 em ordem
  ```python
  # Verificar se podemos entregar pacotes em ordem
  while expected_seq in buffer:
      received_segments.append(buffer[expected_seq])
      del buffer[expected_seq]  # Remover do buffer
      print(f"[DELIVER] Segmento {expected_seq} entregue em ordem")
      expected_seq += 1
  ```

**Estado das Vari√°veis:**

- buffer: {} ‚Üí {3: "sta ", 4: "√© um"} ‚Üí {} (ap√≥s entrega)
- expected_seq: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5

**Resultado:** Apenas pacote perdido √© retransmitido, pacotes v√°lidos s√£o preservados no buffer.

### 7.7 Selective Repeat - Cen√°rio de Pacote Corrompido

**Situa√ß√£o:** Pacote 2 chega corrompido, pacotes 3 e 4 chegam v√°lidos.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4]
- Passo 2: Recebe ACKs 0, 1, 3, 4
- Passo 3: Recebe NACK 2
- Passo 4: Retransmite apenas pacote 2 (linhas 213-222 em client.py)

**Servidor:**

- Passo 1: Processa pacotes 0, 1, 3, 4 corretamente
- Passo 2: Detecta corrup√ß√£o no pacote 2 (linhas 116-164 em server.py)
  ```python
  if verify_checksum(payload, checksum):
      # Processa pacote v√°lido
  else:
      nack = create_nack_packet(seq_num)
      send_message(client_socket, nack)
  ```
- Passo 3: Envia NACK apenas para pacote 2
- Passo 4: Recebe retransmiss√£o do pacote 2, processa corretamente

**Estado das Vari√°veis:**

- buffer: {3: "sta ", 4: "√© um"} (preservado)
- expected_seq: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5

**Resultado:** Apenas pacote corrompido √© retransmitido, pacotes v√°lidos permanecem no buffer.

### 7.8 Selective Repeat - Cen√°rio de Timeout

**Situa√ß√£o:** ACK 2 √© perdido, mas pacotes 3 e 4 chegam ao servidor.

**Cliente:**

- Passo 1: Envia janela [0,1,2,3,4]
- Passo 2: Recebe ACKs 0, 1, 3, 4
- Passo 3: Timer do pacote 2 expira (5 segundos)
- Passo 4: Retransmite apenas pacote 2 (linhas 65-80 em client.py)

**Servidor:**

- Passo 1: Processa pacotes 0, 1, 3, 4
- Passo 2: Armazena pacotes 3 e 4 no buffer
- Passo 3: Recebe retransmiss√£o do pacote 2
- Passo 4: Entrega pacotes 2, 3, 4 em ordem

**Estado das Vari√°veis:**

- buffer: {3: "sta ", 4: "√© um"} ‚Üí {} (ap√≥s entrega)
- timers: {2: timer2} ‚Üí {} (ap√≥s ACK)

**Resultado:** Timeout detecta perda de ACK e retransmite apenas pacote espec√≠fico.

## Exemplo de Execu√ß√£o

### Output do Servidor

```
Servidor iniciado em localhost:8080
Aguardando conex√µes...
Conex√£o estabelecida com ('127.0.0.1', 64768)
Iniciando handshake...
Dados recebidos: {'type': 'handshake', 'max_message_size': 100, 'operation_mode': 'selective_repeat'}
Handshake conclu√≠do:
  - Tamanho m√°ximo: 100
  - Modo: selective_repeat

=== INICIANDO TROCA DE MENSAGENS ===
[SR] Iniciando Selective Repeat com janela de tamanho: 5
[BUFFER] Buffer de recebimento: 10 pacotes
Pacote recebido: {'type': 'data', 'seq_num': 0, 'payload': 'Ol√° ', 'checksum': 188}
[OK] Pacote 0 v√°lido: 'Ol√° ' (checksum: 188)
[BUFFER] Pacote 0 armazenado no buffer
[DELIVER] Segmento 0 entregue em ordem
[ACK] ACK enviado para pacote 0
[BUFFER] Buffer vazio

=== MENSAGEM COMPLETA RECEBIDA ===
Texto: Ol√° mundo! Esta √© uma mensagem de teste para o protocolo de transporte confi√°vel.
Total de segmentos: 21
Tamanho total: 81 caracteres

=== TROCA DE MENSAGENS CONCLU√çDA ===
Conex√£o com ('127.0.0.1', 64768) encerrada
```

### Output do Cliente

```
Conectado ao servidor localhost:8080
Iniciando handshake...
Enviando: {'type': 'handshake', 'max_message_size': 100, 'operation_mode': 'selective_repeat'}
Resposta recebida: {'type': 'handshake_ack', 'max_message_size': 100, 'window_size': 5, 'operation_mode': 'selective_repeat', 'status': 'success'}
Handshake conclu√≠do!

=== INICIANDO TROCA DE MENSAGENS ===
Texto a ser enviado: Ol√° mundo! Esta √© uma mensagem de teste para o protocolo de transporte confi√°vel.
Tamanho da mensagem: 81 caracteres
[OK] Mensagem dentro do limite de 100 caracteres
Segmentos criados: ['Ol√° ', 'mund', 'o! E', 'sta ', '√© um', 'a me', 'nsag', 'em d', 'e te', 'ste ', 'para', ' o p', 'roto', 'colo', ' de ', 'tran', 'spor', 'te c', 'onfi', '√°vel', '.']

[SR] Iniciando Selective Repeat com janela de tamanho: 5
[SEND] Enviando pacote 0: 'Ol√° ' (checksum: 188)
[TIMER] Timer iniciado para pacote 0 (5.0s)
[SEND] Enviando pacote 1: 'mund' (checksum: 180)
[TIMER] Timer iniciado para pacote 1 (5.0s)
[SEND] Enviando pacote 2: 'o! E' (checksum: 245)
[TIMER] Timer iniciado para pacote 2 (5.0s)
[SEND] Enviando pacote 3: 'sta ' (checksum: 104)
[TIMER] Timer iniciado para pacote 3 (5.0s)
[SEND] Enviando pacote 4: '√© um' (checksum: 235)
[TIMER] Timer iniciado para pacote 4 (5.0s)
[ACK] ACK recebido para pacote 0
[TIMER] Timer cancelado para pacote 0
[WINDOW] Janela movida. Base agora: 1
[ACK] ACK recebido para pacote 1
[TIMER] Timer cancelado para pacote 1
[WINDOW] Janela movida. Base agora: 2

=== TROCA DE MENSAGENS CONCLU√çDA ===
[TIMER] Todos os timers cancelados
Desconectado
```
